<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Deduplication Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js">
        Chart.defaults.font.family = 'Arial, sans-serif';
        Chart.defaults.font.size = 12;
        Chart.defaults.color = '#ffffff';
    </script>
    <style>
        /* CSS config */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #333333;
            color: #ffffff;
        }

        canvas {
            background-color: #333333;
        }

        .form-group {
            margin-bottom: 10px;
            max-width: 400px;
        }

        label {
            display: block;
            margin-bottom: 5px;
        }

        input {
            padding: 5px;
            width: 100%;
        }

        .chart-container {
            width: 100%;
            max-width: 800px;
            margin-top: 30px;
        }

        fieldset {
            border: none;
        }

        .input-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap;
            margin-bottom: 12px;
        }

        .input-group label {
            flex: 1;
            white-space: nowrap;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            /* fill the .input-group width */
        }

        .input-group input .label-text {
            flex: 1;
            text-align: left;
            margin-right: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .input-group input {
            width: 80px;
            text-align: center;
        }

        .container {
            display: flex;
            gap: 40px;
            align-items: flex-start;
            margin-bottom: 40px;
        }

        .column {
            flex: 1;
            max-width: 30%;
        }

        .chart-box {
            position: relative;
            width: 100%;
            height: 400px;
            position: relative;
            border: 2px solid #FB4F14;
            border-radius: 8px;
            margin-bottom: 20px;
            box-sizing: border-box;
            padding: 0;
            overflow: hidden;

        }

        .chart-box canvas {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100% !important;
            height: 100% !important;
            color: #333333;
        }

        #charts {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .chart-wrapper {
            display: flex;
            flex-direction: column;
            gap: 30px;
            padding-right: 20px;
            box-sizing: border-box;
        }
    </style>
</head>

<body>
    <!-- Container for input variables-->
    <div class="container">
        <!-- Inputs -->
        <div id="inputs" class="column">
            <h1>Deduplication Simulator</h1>
            <h2>Input Parameters</h2>
            <fieldset>
                <div class="input-group">
                    <label for="sourceSize">1. Source Data Size (TiB)</label>
                    <input type="number" id="sourceSize" value="10" step="0.1" />
                </div>
                <div class="input-group">
                    <label for="changeRate">2. Daily Change Rate (%)</label>
                    <input type="number" id="changeRate" value="2" />
                </div>
                <div class="input-group">
                    <label for="dailyRetention">3. Daily Retention (days)</label>
                    <input type="number" id="dailyRetention" value="12" />
                </div>
                <div class="input-group">
                    <label for="weeklyRetention">4. Weekly Retention (count)</label>
                    <input type="number" id="weeklyRetention" value="4" />
                </div>
                <div class="input-group">
                    <label for="monthlyRetention">5. Monthly Retention (count)</label>
                    <input type="number" id="monthlyRetention" value="11" />
                </div>
                <div class="input-group">
                    <label for="yearlyRetention">6. Yearly Retention (count)</label>
                    <input type="number" id="yearlyRetention" value="7" />
                </div>
                <div class="input-group">
                    <label for="simulationMonths">7. Simulation Time (months)</label>
                    <input type="number" id="simulationMonths" value="89" />
                </div>
                <div class="input-group">
                    <label for="compression">8. Compression Savings (%)</label>
                    <input type="number" id="compression" value="50" step="1" />
                </div>
                <div class="input-group">
                    <label for="cloudDelay">9. Days Before Data Moves to Cloud</label>
                    <input type="number" id="cloudDelay" value="5" />
                </div>
            </fieldset>
            <div id="controls">
                <!-- First row: Generate & Reset -->
                <div class="control-row">
                    <button id="generateBtn">Generate Charts</button>
                    <button id="resetBtn" type="button">Reset Inputs</button>
                </div>

                <!-- Second row: Report Name & Export -->
                <div class="control-row" style="margin-top:16px;">
                    <input id="reportName" type="text" placeholder="Server Name" value=""
                        style="width: 132px; padding:4px; font-size:0.9em;" />
                    <button id="exportCsvBtn" type="button">Export to CSV</button>
                </div>
            </div>

        </div>

        <!-- Stats Panel -->
        <div id="stats" class="column">
            <h1>Simulation Summary</h1>
            <h2>Results</h2>
            <p><strong>Total Logical Data Ingested:</strong> <span id="totalRawDataTiB">-</span>TiB</p>
            <p><strong>Total Stored Data:</strong> <span id="storedDataOverTime">-</span>TiB</p>
            <p><strong>Total logical Data held: </strong><span id="heldRawDataTiB">-</span>TiB</p>
            <p><strong>Number of Retained Backups: </strong><span id="snapshotsHeld">-</span></p>
            <p><strong>Deduplication Pre-Compression:</strong> <span id="dedupePreCompression">-</span>%</p>
            <p><strong>Deduplication Post-Compression:</strong> <span id="finalEfficiency">-</span>%</p>
            <p><strong>Total Cloud Data:</strong> <span id="totalCloud">-</span>TiB</p>
        </div>
        <div class="column" id="dict">
            <h1>Dictionary & Meta-Data</h1>
            <h2>Results</h2>
            <p><strong>Required Keys :</strong> <span id="requiredKeys">-</span></p>
            <p><strong>Total Max Keys Available:</strong> <span id="totalMaxKeys">-</span></p>
            <p><strong>Used Keys Percentage:</strong> <span id="usedKeysPercent">-</span></p>
            <p><strong>Base RAM Required:</strong> <span id="keyTierBase">-</span></p>
            <p><strong>Dictionary Size Required:</strong> <span id="keyTierSize">-</span></p>
            <p><strong>Additional RAM Required:</strong> <span id="keyTierAddRAM">-</span></p>
            <p><strong>Bit Shift Setting:</strong> <span id="keyTierShift">-</span></p>
            <p><strong>Page Shift Setting:</strong> <span id="keyTierPage">-</span></p>
            <p><strong>Meta Data Size:</strong> <span id="blockMapSize">-</span>GiB</p>
            <div id="recommendedConfig">
                <h2>Recommended Configuration</h2>
                <p><strong>Base RAM:</strong> <span id="recKeyTierBase">‚Äì</span></p>
                <p><strong>Dictionary Size:</strong> <span id="recKeyTierSize">‚Äì</span></p>
                <p><strong>Additional RAM:</strong> <span id="recKeyTierAddRAM">‚Äì</span></p>
                <p><strong>Shift:</strong> <span id="recKeyTierShift">‚Äì</span></p>
                <p><strong>Page Shift:</strong> <span id="recKeyTierPage">‚Äì</span></p>
            </div>
        </div>
    </div>
</body>
<!-- Chart space -->
<div id="charts">
    <div class="chart-wrapper">
        <div class="chart-box">
            <h3>Stored Data Over Time</h3>
            <canvas id="storageChart"></canvas>
        </div>
        <div class="chart-box">
            <h3>Deduplication Efficiency Over Time</h3>
            <canvas id="dedupeChart"></canvas>
        </div>
        <div class="chart-box">
            <h3>Required Keys Over Time</h3>
            <canvas id="keysChart"></canvas>
        </div>
        <div id="keys-tooltip" class="chartjs-tooltip"
            style="pointer-events:none; position:absolute; background:rgba(0,0,0,0.8); color:#fff; border-radius:4px; padding:8px; font-size:12px; display:none;">
        </div>

        <div class="chart-box">
            <h3>Dictionary Tier Over Time</h3>
            <canvas id="DictChart"></canvas>
        </div>
        <div class="chart-box">
            <h3>Local vs Cloud Storage Over Time</h3>
            <canvas id="cloudChart"></canvas>
        </div>
        <div class="chart-box">
            <h3>Meta-Data Size Over Time</h3>
            <canvas id="blockMapChart"></canvas>
        </div>
        <div class="chart-box">
            <h3>Daily New Data: Uncompressed vs Compressed</h3>
            <canvas id="deltaChart"></canvas>
        </div>
    </div>
</div>


<script>
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Lookup table for dictionary sizing
    const keyLookupTable = [
        { min: 0, max: 2_863_355_222, Base_RAM: "4096MB", Size: "64GiB", Additional_RAM: "0", Shift: "19", Page_Shift: "12" },
        { min: 2_863_355_223, max: 5_726_710_444, Base_RAM: "4096MB", Size: "128GiB", Additional_RAM: "0MB", Shift: "20", Page_Shift: "12" },
        { min: 5_726_710_445, max: 11_453_420_886, Base_RAM: "8192MB", Size: "256GiB", Additional_RAM: "0MB", Shift: "21", Page_Shift: "12" },
        { min: 11_453_420_887, max: 22_906_841_772, Base_RAM: "8192MB", Size: "384GiB", Additional_RAM: "1412MB", Shift: "22", Page_Shift: "12" },
        { min: 22_906_841_773, max: 45_813_683_542, Base_RAM: "16384MB", Size: "640GiB", Additional_RAM: "2576MB", Shift: "23", Page_Shift: "12" },
        { min: 45_813_683_543, max: 91_627_367_084, Base_RAM: "32768MB", Size: "1.52TiB", Additional_RAM: "4880MB", Shift: "24", Page_Shift: "12" },
        { min: 91_627_367_085, max: 183_254_734_166, Base_RAM: "65536MB", Size: "2.176TiB", Additional_RAM: "9488MB", Shift: "25", Page_Shift: "12" },
        { min: 183_254_734_167, max: 366_509_468_332, Base_RAM: "65536MB", Size: "4.224TiB", Additional_RAM: "18704MB", Shift: "26", Page_Shift: "12" }
    ];

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 1) The simulator with 8-day ‚Äúfull backup‚Äù anchoring
    function simulateRetention(
        days, sourceSizeTiB, changeRate, compressionPercent,
        dailyRetention, weeklyRetention, monthlyRetention,
        yearlyRetention, cloudDelay
    ) {
        const rampUpDays = 3;
        const backupLog = [];
        const uncompressedDataOverTime = [];
        const storedLocallyOverTime = [];
        const storedInCloudOverTime = [];
        const dedupeEfficiencyOverTime = [];
        const dedupePreCompressionOverTime = [];
        const retainedLogicalOverTime = [];
        const requiredKeysSeries = [];
        const dictionarySizesOverTime = [];
        const tierMetaOverTime = [];
        const retainedCountsOverTime = [];
        const compressedDataOverTime = [];
        const uncompressedLocalOverTime = [];
        const uncompressedCloudOverTime = [];
        const blockMapOverTime = [];
        const dailyUncompressedDelta = [];
        const dailyCompressedDelta = [];

        const dailyCut = dailyRetention;                  // 12
        const weeklyCut = dailyCut + weeklyRetention * 7;  // 12 + 4*7  = 40
        const monthlyCut = weeklyCut + monthlyRetention * 30; // 40 + 11*30 = 370
        const yearlyCut = monthlyCut + yearlyRetention * 365; // 370 + 7*365 = 2675

        const stats = {
            totalLogicalTiB: 0,
            totalUncompressedTiB: 0,
            totalStorageTiB: 0,
            totalCloudTiB: 0,
            dictionary: {}
        };

        let lastSnapshot = sourceSizeTiB;

        // ‚òÖ new compressed‚Äêarchive accumulator ‚òÖ
        let lastCompressedArchive = 0;             // ‚Üê initialize before loop

        // 1Ô∏è‚É£ build backupLog with fixed‚Äêdelta growth
        for (let day = 0; day < days; day++) {
            //const effectiveCompression = compressionPercent * compressionRamp;
            // apply exactly 10% on the very first snapshot, then use the configured rate thereafter
            const effectiveCompression = (day === 0)
                ? 0.10                // always 10% on Day 0
                : compressionPercent; // user-entered % from Day 1 onward

            const dedupedSize = day === 0
                ? sourceSizeTiB
                : sourceSizeTiB * changeRate;                   // fixed % of original

            const logicalSize = day === 0
                ? sourceSizeTiB
                : lastSnapshot + dedupedSize;                   // linear accumulation

            const compressedSize = dedupedSize * (1 - effectiveCompression);
            const fullCompressedSize = logicalSize * (1 - effectiveCompression);

            // ‚Üì‚Üì‚Üì  COMPOUND THE COMPRESSED DELTA INTO A RUNNING TOTAL ‚Üì‚Üì‚Üì
            if (day === 0) {
                lastCompressedArchive = fullCompressedSize;
            } else {
                lastCompressedArchive += compressedSize;
            }
            compressedDataOverTime.push(lastCompressedArchive);
            // ‚Üë‚Üë‚Üë

            //daily bookkeeping
            dailyUncompressedDelta.push(dedupedSize);
            dailyCompressedDelta.push(compressedSize);
            lastSnapshot = logicalSize;

            const tiers = ['daily'];
            if (day % 7 === 0) tiers.push('weekly');
            if (day % 30 === 0) tiers.push('monthly');
            if (day % 365 === 0) tiers.push('yearly');

            backupLog.push({
                day, logicalSize, dedupedSize,
                compressedSize, fullCompressedSize, tiers
            });
        }
        // 2Ô∏è‚É£ simulate retention + local/cloud split
        for (let currentDay = 0; currentDay < days; currentDay++) {
            let retainedCount = 0;
            let totalLogical = 0;
            let totalUncompressed = 0;
            let totalCompressed = 0;
            let localSum = 0;
            let cloudSum = 0;
            let uncompressedLocal = 0;
            let uncompressedCloud = 0;

            for (const b of backupLog) {
                const age = currentDay - b.day;
                if (age < 0) continue;
                const keep =
                    // 1) daily: any snapshot younger than D days
                    (age < dailyCut)
                    // 2) weekly: one per week, but only in [D, weeklyCut)
                    || (age >= dailyCut
                        && age < weeklyCut
                        && b.tiers.includes('weekly'))
                    // 3) monthly: one per month, but only in [weeklyCut, monthlyCut)
                    || (age >= weeklyCut
                        && age < monthlyCut
                        && b.tiers.includes('monthly'))
                    // 4) yearly: one per year, but only in [monthlyCut, yearlyCut)
                    || (age >= monthlyCut
                        && age < yearlyCut
                        && b.tiers.includes('yearly'));
                if (!keep) continue;

                //Retention policy to get to the correct number of savepoints in heldRawTiB

                // Count every snapshot that passes retention
                retainedCount++;

                // Only sum the *new* delta for logical
                totalLogical += b.dedupedSize;
                totalUncompressed += b.dedupedSize;

                //Split the *uncompressed dedupe bytes by tier
                if (b.day === 0 || (currentDay - b.day) < cloudDelay) {
                    uncompressedLocal += b.dedupedSize;
                }
                if ((currentDay - b.day) >= cloudDelay) {
                    uncompressedCloud += b.dedupedSize;
                }

                // Single compressed contribution
                const contrib = b.day === 0
                    ? b.fullCompressedSize
                    : b.compressedSize;

                totalCompressed += contrib;

                // 1) everything younger than the cloud delay stays local
                // 2) once age >= cloudDelay, it lives in the cloud
                if (b.day === 0 || age < cloudDelay) {
                    localSum += contrib;
                }
                if (age >= cloudDelay) {
                    cloudSum += contrib;
                }
            }
            //2.2 pushing retained count
            retainedCountsOverTime.push(retainedCount)
            retainedLogicalOverTime.push(totalLogical);
            uncompressedDataOverTime.push(totalUncompressed);

            // üî≥ New: Block‚Äêmap size over time (GiB)
            //   rawHeldTiB ‚Üí KiB (√ó1024¬≥) ‚Üí # 8‚ÄêKiB blocks (√∑8) ‚Üí √ó48 bytes ‚Üí GiB (√∑1024¬≥)
            // simplifies to rawHeldTiB √ó 6 GiB
            const blockMapThisDay = (sourceSizeTiB * retainedCount) * 3;
            blockMapOverTime.push(blockMapThisDay);

            // storedDataOverTime.push(totalCompressed);
            storedLocallyOverTime.push(localSum);
            storedInCloudOverTime.push(cloudSum);
            //compressedDataOverTime.push(totalCompressed);

            // look up yesterday‚Äôs running total (or zero on Day 0)
            const prevCompounded = currentDay > 0
                ? compressedDataOverTime[currentDay - 1]
                : 0;
            // add today‚Äôs compressed delta
            const compounded = prevCompounded + totalCompressed;
            compressedDataOverTime.push(compounded);
            compressedDataOverTime.push(totalCompressed);
    
            uncompressedLocalOverTime.push(uncompressedLocal);
            uncompressedCloudOverTime.push(uncompressedCloud);

            // NEW: sum local + cloud unique data into one series
            const newTotalUncompressedOverTime = uncompressedLocalOverTime.map(
                (loc, i) => loc + uncompressedCloudOverTime[i]
            );

            // Dedupe % based on raw‚Äêheld vs stored
            // rawHeld = raw backup size √ó # of snapshots still kept
            const rawHeld = sourceSizeTiB * retainedCount;

            // actual stored = local + cloud
            const stored = localSum + cloudSum;


            // post‚Äêcompression dedupe = (rawHeld ‚Äì stored) / rawHeld √ó 100
            const postEff = rawHeld > 0
                ? ((rawHeld - totalCompressed) / rawHeld) * 100
                : 0;

            // pre‚Äêcompression dedupe = (rawHeld ‚Äì totalUncompressed) / rawHeld √ó 100
            const preEff = rawHeld > 0
                ? ((rawHeld - totalUncompressed) / rawHeld) * 100
                : 0;

            dedupeEfficiencyOverTime.push(Math.max(0, postEff));
            dedupePreCompressionOverTime.push(Math.max(0, preEff));

            // üîë Keys based on the deduped+compressed footprint
            // totalCompressed is already the sum of all contrib for today
            const footprintTiB = localSum + cloudSum;
            const numKeys = Math.floor(footprintTiB * (1024 ** 3) / 8);
            requiredKeysSeries.push(numKeys);

            const match = keyLookupTable.find(
                k => numKeys >= k.min && numKeys <= k.max
            ) || {};
            tierMetaOverTime.push(match);
            dictionarySizesOverTime.push(match.Size || 'N/A');


            //logging for value checking - Comment out if not required
            if (currentDay === days - 1) {
                console.log({
                    totalCompressedTiB: footprintTiB.toFixed(2),
                    kib: (footprintTiB * (1024 ** 3)).toFixed(0),
                    numKeys,
                    expected: Math.floor((footprintTiB * (1024 ** 3)) / 8)
                });
            }
        } //End of retention loop

        // ‚îÄ‚îÄ after the retention loop, set time series data  ‚îÄ‚îÄ
        const storedDataOverTime = storedLocallyOverTime.map(
            (loc, i) => loc + storedInCloudOverTime[i]
        );

        // ‚îÄ‚îÄ Replace the old totalStorageTiB with the compressed footprint ‚îÄ‚îÄ
        const lastLocal = storedLocallyOverTime.at(-1) || 0;
        const lastCloud = storedInCloudOverTime.at(-1) || 0;
        stats.totalLocalStoredTiB = lastLocal;
        stats.totalCloudStoredTiB = lastCloud;
        stats.totalStoredTiB = lastLocal + lastCloud;

        const newTotalUncompressedOverTime = uncompressedLocalOverTime.map(
            (loc, i) => loc + uncompressedCloudOverTime[i]
        );

        //-- after retnetion loop, coumpute raw-held volume --
        // full raw backup size x how many snapshots are retained each day
        const heldRawDataOverTime = retainedCountsOverTime.map(
            count => sourceSizeTiB * count
        );


        // 3Ô∏è‚É£ final‚Äêstats

        // Collect total logical data pre-dedupe & compression
        const numBackups = days;
        stats.totalLogicalTiB = sourceSizeTiB * numBackups

        // Raw-backup volume still held under retention
        stats.heldRawDataTiB = heldRawDataOverTime.at(-1);
        stats.snapshotsHeld = retainedCountsOverTime.at(-1) || 0;
        stats.totalUncompressedTiB = uncompressedDataOverTime.at(-1) || 0;
        stats.totalCloudTiB = storedInCloudOverTime.at(-1) || 0;


        // final dictionary stats using time series data
        stats.totalCompressedTiB = compressedDataOverTime.at(-1) || 0;

        //const finalKeys = requiredKeysSeries[requiredKeysSeries.length - 1];
        //const finalTier = tierMetaOverTime[requiredKeysSeries.length - 1];

        const finalKeys = requiredKeysSeries.at(-1);
        const foundTier = tierMetaOverTime.at(-1);
        const finalTier = foundTier || { max: 0, Size: 'N/A', Base_RAM: 'N/A', Additional_RAM: 'N/A', Shift: 'N/A', Page_Shift: 'N/A' };

        const usedPct = finalTier.max
            ? (finalKeys / finalTier.max) * 100
            : 0;

        stats.dictionary = {
            requiredKeys: finalKeys,
            tier: finalTier,
            usedPct
        };

        // ‚îÄ‚îÄ New Block Map Size Stat ‚îÄ‚îÄ
        // 1) TiB ‚Üí KiB
        const rawHeldKiB = stats.heldRawDataTiB * (1024 ** 3);
        // 2) one block = 8 KiB ‚Üí total blocks
        const totalBlocks = rawHeldKiB / 16;
        // 3) each block entry is 48 bytes ‚Üí map bytes
        const blockMapBytes = totalBlocks * 48;
        // 4) bytes ‚Üí GiB
        stats.blockMapSizeGiB = blockMapBytes / (1024 ** 3);

        // after final‚Äêdict calculation:
        const finalCompressedTiB = compressedDataOverTime.at(-1) || 0;

        return {
            storedDataOverTime,
            uncompressedDataOverTime,
            compressedDataOverTime,
            storedLocallyOverTime,
            storedInCloudOverTime,
            dedupeEfficiencyOverTime,
            dedupePreCompressionOverTime,
            retainedLogicalOverTime,
            requiredKeysSeries,
            dictionarySizesOverTime,
            tierMetaOverTime,
            heldRawDataOverTime,
            uncompressedLocalOverTime,
            uncompressedCloudOverTime,
            newTotalUncompressedOverTime,
            blockMapOverTime,
            dailyUncompressedDelta,
            dailyCompressedDelta,
            stats
        };
    }


    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Chart option helper
    function getChartOptions(title, xLabel, yLabel, yMax = null) {
        return {
            maintainAspectRatio: false,
            responsive: true,
            layout: {
                padding: {
                    top: 10,
                    right: 10,
                    bottom: 10,
                    left: 10
                }
            },
            plugins: {
                legend: { labels: { color: '#ffffff' } },
                title: {
                    display: true,
                    text: title,
                    font: { size: 14, family: 'Arial, sans-serif' }, //explicit
                    color: '#ffffff'
                }
            },
            scales: {
                x: {
                    grid: { color: '#444444' },
                    ticks: {
                        font: { size: 10, family: 'Arial, sans-serif' },
                        color: '#ffffff'
                    },
                    title: {
                        display: true,
                        text: xLabel,
                        font: { size: 12, family: 'Arial, sans-serif' },
                        color: '#ffffff'
                    }
                },
                y: {
                    grid: { color: '#444444' },
                    beginAtZero: true,
                    max: yMax,
                    ticks: {
                        font: { size: 10, family: 'Arial, sans-serif' },
                        color: '#ffffff'
                    },
                    title: {
                        display: true,
                        text: yLabel,
                        font: { size: 12, family: 'Arial, sans-serif' },
                        color: '#ffffff'
                    }
                }
            }
        };
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // The main entrypoint to chart the simulation.
    function generateCharts() {
        // gather inputs
        const sourceSizeTiB = parseFloat(document.getElementById('sourceSize').value);
        const changeRate = parseFloat(document.getElementById('changeRate').value) / 100;
        const dailyRetention = parseInt(document.getElementById('dailyRetention').value, 10);
        const weeklyRetention = parseInt(document.getElementById('weeklyRetention').value, 10);
        const monthlyRetention = parseInt(document.getElementById('monthlyRetention').value, 10);
        const yearlyRetention = parseInt(document.getElementById('yearlyRetention').value, 10);
        const simMonths = parseInt(document.getElementById('simulationMonths').value, 10);
        const compressionPct = parseFloat(document.getElementById('compression').value) / 100;
        const cloudDelay = parseInt(document.getElementById('cloudDelay').value, 10);

        const days = simMonths * 30;
        const daysLabels = Array.from({ length: days }, (_, i) => `Day ${i + 1}`);

        //Call simulateRetention() function for required information with gathered variable
        const {
            storedDataOverTime, storedLocallyOverTime, storedInCloudOverTime,
            dedupeEfficiencyOverTime, dedupePreCompressionOverTime,
            retainedLogicalOverTime, requiredKeysSeries,
            dictionarySizesOverTime, tierMetaOverTime, heldRawDataOverTime, blockMapOverTime, stats, storedTiB,
            uncompressedDataOverTime, compressedDataOverTime, uncompressedLocalOverTime, uncompressedCloudOverTime,
            newTotalUncompressedOverTime, dailyUncompressedDelta, dailyCompressedDelta
        } = simulateRetention(
            days, sourceSizeTiB, changeRate, compressionPct,
            dailyRetention, weeklyRetention, monthlyRetention,
            yearlyRetention, cloudDelay
        );
        //End of Simulation call.

        // Create Stats from retention time series
        stats.dedupePostCompressionPct = dedupeEfficiencyOverTime.at(-1) || 0;
        stats.dedupePreCompressionPct = dedupePreCompressionOverTime.at(-1) || 0;
        stats.totalCompressedTiB = compressedDataOverTime.at(-1) || 0;

        const allDeltas = dailyUncompressedDelta.concat(dailyCompressedDelta);
        const deltaMax = Math.max(...allDeltas);
        const deltaMin = Math.min(...allDeltas);


        //total uncomoressed unique data each day
        const totalUncompressedOverTime = uncompressedLocalOverTime.map(
            (loc, i) => loc + uncompressedCloudOverTime[i]
        );

        // final ‚Äúraw held‚Äù TiB from your loop
        const finalRawHeldTiB = stats.heldRawDataTiB;


        // final total unique-but-uncompressed footprint
        const finalUncomp = totalUncompressedOverTime.at(-1) || 0;


        // pre-compression efficiency
        stats.dedupePreCompressionPct = finalRawHeldTiB > 0
            ? ((finalRawHeldTiB - finalUncomp) / finalRawHeldTiB) * 100
            : 0;


        // monthly down-sampling
        const monthLabels = Array.from({ length: simMonths }, (_, i) => `Month ${i + 1}`);

        // End of month alighnment for required keys and required dict sizing
        const daysCount = requiredKeysSeries.length;
        const lastIdx = daysCount - 1;

        const monthlyKeys = monthLabels.map((_, m) => {
            // ideal end-of-month index
            const ideal = (m + 1) * 30 - 1;
            // clamp so we never overshoot the last day
            const idx = Math.min(ideal, lastIdx);
            return requiredKeysSeries[idx] || 0;
        });

        const monthlyDict = monthLabels.map((_, m) => {
            const ideal = (m + 1) * 30 - 1;
            const idx = Math.min(ideal, lastIdx);
            return dictionarySizesOverTime[idx] || 'N/A';
        });

        const monthlyMeta = monthLabels.map((_, m) => {
            const ideal = (m + 1) * 30 - 1;
            const idx = Math.min(ideal, lastIdx);
            return tierMetaOverTime[idx] || {};
        });

        // Logging to check values - comment out if not required
        console.log({
            daysCount,
            lastIdx,
            monthLabels,
            monthlyKeys,
            lastRequiredKey: requiredKeysSeries[lastIdx],
            lastMonthlyKey: monthlyKeys[monthlyKeys.length - 1]
        });

        //calculate total stored data
        const finalLocalTiB = storedLocallyOverTime.at(-1);
        const finalCloudTiB = storedInCloudOverTime.at(-1);
        //stats.totalLocalStoredTiB = finalLocalTiB;
        //stats.totalCloudStoredTiB = finalCloudTiB;
        //stats.totalStoredTiB = finalLocalTiB + finalCloudTiB;

        // ‚îÄ‚îÄ‚îÄ Update Stats Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const totLogical = stats.totalLogicalTiB;
        const totUncomp = stats.totalUncompressedTiB;
        const totStored = stats.totalStoredTiB;
        const totCloud = stats.totalCloudTiB;
        const heldRawDataTiB = stats.heldRawDataTiB;

        //document.getElementById('totalRawDataTiB').textContent = totLogical.toFixed(2);
        document.getElementById('totalRawDataTiB').textContent = totLogical.toLocaleString(2);
        document.getElementById('storedDataOverTime').textContent = stats.totalStoredTiB.toLocaleString(undefined, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
        document.getElementById('dedupePreCompression').textContent = stats.dedupePreCompressionPct.toLocaleString(undefined, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
        document.getElementById('finalEfficiency').textContent = stats.dedupePostCompressionPct.toLocaleString(undefined, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
        document.getElementById('totalCloud').textContent = totCloud.toLocaleString(undefined, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
        document.getElementById('heldRawDataTiB').textContent = heldRawDataTiB.toLocaleString(undefined, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
        document.getElementById('snapshotsHeld').textContent = stats.snapshotsHeld.toLocaleString();
        document.getElementById('blockMapSize').textContent = stats.blockMapSizeGiB.toLocaleString(2);

        // dictionary final
        const { requiredKeys, tier, usedPct } = stats.dictionary;
        document.getElementById('requiredKeys').textContent = stats.dictionary.requiredKeys.toLocaleString();
        document.getElementById('totalMaxKeys').textContent = (tier.max || 0).toLocaleString();
        document.getElementById('usedKeysPercent').textContent = usedPct.toFixed(2);
        // ‚îÄ‚îÄ‚îÄ Update Used Keys Percent ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        //const usedPct = stats.dictionary.usedPct;
        const usedEl = document.getElementById('usedKeysPercent');
        usedEl.textContent = usedPct.toFixed(2) + '%';

        // turn red if ‚â•90%, otherwise default (inherit)
        if (usedPct >= 90) {
            usedEl.style.color = 'red';
        } else if (usedPct >= 80) {
            usedEl.style.color = 'yellow';
        } else {
            usedEl.style.color = 'green';  // fall back to whatever your CSS says
        }
        document.getElementById('keyTierBase').textContent = tier.Base_RAM || 'N/A';
        document.getElementById('keyTierSize').textContent = tier.Size || 'N/A';
        document.getElementById('keyTierAddRAM').textContent = tier.Additional_RAM || 'N/A';
        document.getElementById('keyTierShift').textContent = tier.Shift || 'N/A';
        document.getElementById('keyTierPage').textContent = tier.Page_Shift || 'N/A';

        // Use the stat from the dictionary so it's always defined
        const pctUsed = stats.dictionary.usedPct;
        const currentTier = stats.dictionary.tier;
        const idx = keyLookupTable.findIndex(
            k => k.Size === currentTier.Size &&
                k.Base_RAM === currentTier.Base_RAM
        );

        // Pick the next tier if you‚Äôre over 90%
        let recTier = currentTier;
        if (pctUsed >= 90 && idx >= 0 && idx < keyLookupTable.length - 1) {
            recTier = keyLookupTable[idx + 1];
        }
        // determine if we actually recommended the *next* tier
        const recommendedUp = pctUsed >= 90 && idx >= 0 && idx < keyLookupTable.length - 1;

        // pick your highlight color (or use any valid CSS color)
        const recColor = recommendedUp ? 'green' : 'inherit';
        const recEls = {
            Base: document.getElementById('recKeyTierBase'),
            Size: document.getElementById('recKeyTierSize'),
            AddRAM: document.getElementById('recKeyTierAddRAM'),
            Shift: document.getElementById('recKeyTierShift'),
            Page: document.getElementById('recKeyTierPage'),
        };

        recEls.Base.textContent = recTier.Base_RAM || 'N/A';
        recEls.Size.textContent = recTier.Size || 'N/A';
        recEls.AddRAM.textContent = recTier.Additional_RAM || 'N/A';
        recEls.Shift.textContent = recTier.Shift || 'N/A';
        recEls.Page.textContent = recTier.Page_Shift || 'N/A';

        // apply your color to each
        Object.values(recEls).forEach(el => {
            el.style.color = recColor;
        });

        // ‚îÄ‚îÄ‚îÄ Render Charts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // destroy old charts - clean for new charts
        ['chart1', 'chart2', 'chart3', 'chart4', 'chart5', 'chart6', 'chart7'].forEach(id => {
            if (window[id] instanceof Chart) window[id].destroy();
        });

        // Chart 1: Stored Data
        const totalStoredOverTime = storedLocallyOverTime.map(
            (loc, i) => loc + storedInCloudOverTime[i]
        );
        window.chart1 = new Chart(
            document.getElementById('storageChart').getContext('2d'),
            {
                type: 'line',
                data: {
                    labels: daysLabels, datasets: [{
                        label: 'Stored Data (TiB)', data: totalStoredOverTime,
                        borderColor: 'orange', fill: true, tension: 0.5, pointRadius: 0
                    }]
                }
                , options: getChartOptions('Total Stored Data Over Time', 'Day', 'TiB')
            }
        );

        // Chart 2: Dedup Efficiency
        window.chart2 = new Chart(
            document.getElementById('dedupeChart').getContext('2d'),
            {
                type: 'line',
                data: {
                    labels: daysLabels, datasets: [{
                        label: 'Dedup Efficiency (%)', data: dedupeEfficiencyOverTime,
                        borderColor: 'lightgreen', fill: false, tension: 0.5, pointRadius: 0
                    }]
                }
                , options: getChartOptions('Deduplication & Compression Efficiency Over Time', 'Day', '% Efficiency', 100)
            }
        );

        // Chart 3: Required Keys (monthly)
        window.chart3 = new Chart(
            document.getElementById('keysChart').getContext('2d'),
            {
                type: 'line',
                data: {
                    labels: monthLabels, datasets: [{
                        label: 'Required Keys', data: monthlyKeys,
                        borderColor: '#8b5cf6', fill: true, tension: 0.5,
                        backgroundColor: '#b295f444'
                    }]
                },
                options: {
                    ...getChartOptions('Required Keys Over Time', 'Month', 'Keys'),
                    plugins: {
                        legend: {
                            labels: {
                                color: '#ffffff'
                            }
                        },
                        tooltip: {
                            enabled: false,
                            external: function (context) {
                                // Tooltip element
                                let tooltipEl = document.getElementById('keys-tooltip');
                                // Hide if no tooltip
                                const tooltipModel = context.tooltip;
                                if (tooltipModel.opacity === 0) {
                                    tooltipEl.style.display = 'none';
                                    return;
                                }
                                // Set text
                                const idx = tooltipModel.dataPoints[0].dataIndex;
                                const keys = tooltipModel.dataPoints[0].formattedValue;
                                const meta = monthlyMeta[idx] || {};
                                const used = meta.max
                                    ? (monthlyKeys[idx] / meta.max) * 100
                                    : 0;
                                // Build HTML
                                const usedColor = used >= 90 ? 'red' : used >= 80 ? 'yellow' : 'lightgreen';
                                tooltipEl.innerHTML = `
                                <div>Keys: ${keys}</div>
                                <div style="color:${usedColor}">Used: ${used.toFixed(2)}%</div>
                                `;
                                // Position it
                                const canvas = context.chart.canvas;
                                const position = canvas.getBoundingClientRect();
                                tooltipEl.style.left = position.left + window.pageXOffset + tooltipModel.caretX + 'px';
                                tooltipEl.style.top = position.top + window.pageYOffset + tooltipModel.caretY + 'px';
                                tooltipEl.style.display = 'block';
                            }
                        }
                    }
                }
            }
        );

        // Chart 4: Dictionary Tier (monthly)
        // 1Ô∏è‚É£ Build catagory list
        const sizeCategories = keyLookupTable.map(e => e.Size);
        const uniqueSizeCategories = [...new Set(sizeCategories)].sort((a, b) => {
            const toGiB = s => s.includes("TiB") ? parseFloat(s) * 1024 : parseFloat(s);
            return toGiB(a) - toGiB(b);
        });

        // 2Ô∏è‚É£ Define your per-chart ‚ÄúbaseOpts‚Äù
        const baseOpts4 = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { labels: { color: "#ffffff" } },
                title: { display: true, text: "Dictionary Transitions Over Time", color: "#ffffff" },
                tooltip: {
                    callbacks: {
                        label: ctx => {
                            // `tierMetaOverTime` must be the array you returned from simulateRetention
                            const meta = monthlyMeta[ctx.dataIndex] || {};
                            return [
                                `Size: ${meta.Size || "N/A"}`,
                                `Base RAM: ${meta.Base_RAM || "N/A"}`,
                                `Additional RAM: ${meta.Additional_RAM || "N/A"}`,
                                `Shift: ${meta.Shift || "N/A"}`,
                                `Page Shift: ${meta.Page_Shift || "N/A"}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: "category",
                    labels: monthLabels,           // your array of ["Month 1","Month 2",‚Ä¶]
                    ticks: { color: "#ffffff" },
                    grid: { color: "#444444" },
                    title: { display: true, text: "Months", color: "#ffffff" }
                },
                y: {
                    type: "category",
                    reverse: true,
                    labels: uniqueSizeCategories,  // from step 1
                    ticks: { color: "#ffffff" },
                    grid: { color: "#444444" },
                    title: { display: true, text: "Tier Level", color: "#ffffff" }
                }
            }
        };

        // 3Ô∏è‚É£ Finally, create the chart itself:
        const ctx4 = document
            .getElementById("DictChart")
            .getContext("2d");

        window.chart4 = new Chart(ctx4, {
            type: "line",
            data: {
                labels: monthLabels,
                datasets: [{
                    label: "Dictionary Tier",
                    data: monthlyDict.map((size, i) => ({
                        x: monthLabels[i],
                        y: size
                    })),
                    borderColor: "#f59e0b",
                    backgroundColor: "rgba(245, 158, 11, 0.2)",
                    fill: true,
                    stepped: true
                }]
            },
            options: baseOpts4
        });

        // Custom tool tip for chart 5 - local & cloud consumption totals
        // build a custom options object for chart5

        const cloudOpts = getChartOptions('Local vs Cloud Storage', 'Day', 'TiB');
        cloudOpts.interaction = {
            mode: 'index',    // show both lines on hover
            intersect: false
        };
        cloudOpts.plugins.tooltip = {
            callbacks: {
                // format each line
                label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(2)} TiB`,
                // add a footer with the sum
                footer: items => {
                    const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                    return `Total: ${total.toFixed(2)} TiB`;
                }
            }
        };

        // Chart 5: Local vs Cloud
        window.chart5 = new Chart(
            document.getElementById('cloudChart').getContext('2d'),
            {
                type: 'line',
                data: {
                    labels: daysLabels, datasets: [
                        {
                            label: 'Local (TiB)', data: storedLocallyOverTime,
                            borderColor: '#4ade80',
                            fill: origin, stack: 's', tension: 0.5, pointRadius: 0,

                        },
                        {
                            label: 'Cloud (TiB)', data: storedInCloudOverTime,
                            borderColor: '#60a5fa',
                            fill: -1, stack: 's', tension: 0.5, pointRadius: 0
                        }
                    ]
                }

                //options: getChartOptions('Local vs Cloud Storage', 'Day', 'TiB')
                , options: cloudOpts
            }
        );
        // Chart 6: Meta-Data Size Over Time
        window.chart6 = new Chart(
            document.getElementById('blockMapChart').getContext('2d'),
            {
                type: 'line',
                data: {
                    labels: daysLabels,
                    datasets: [{
                        label: 'Meta-Data Size (GiB)',
                        data: blockMapOverTime,
                        borderColor: '#f59e0b',
                        fill: true,
                        tension: 0.5, pointRadius: 0
                    }]
                },
                options: getChartOptions('Meta-Data Size Over Time', 'Day', 'GiB')
            }
        );

        // drop the index-0 ‚ÄúDay 0‚Äù datapoint since your deltas really start on Day 1
        const deltaLabels = daysLabels.slice(1);
        const uncmp = dailyUncompressedDelta.slice(1);
        const cmp = dailyCompressedDelta.slice(1);

        // compute min/max on your trimmed arrays (optional)
        const allD = uncmp.concat(cmp);
        const maxD = Math.max(...allD);
        const deltaOpts = getChartOptions(
            'Daily New Data: Uncompressed vs Compressed',
            'Day',
            'TiB'
        );
        deltaOpts.scales.y.max = maxD * 1.1;

        window.chart7 = new Chart(
            document.getElementById('deltaChart').getContext('2d'),
            {
                type: 'line',
                data: {
                    labels: deltaLabels,
                    datasets: [
                        {
                            label: 'Uncompressed Delta Œî (TiB)',
                            data: uncmp,
                            borderColor: 'cyan',
                            tension: 0.5,
                            pointRadius: 0,
                            fill: false
                        },
                        {
                            label: 'Compressed Delta Œî (TiB)',
                            data: cmp,
                            borderColor: 'magenta',
                            tension: 0.5,
                            pointRadius: 0,
                            fill: false
                        }
                    ]
                },
                options: deltaOpts
            }
        );
    }
    //When button is pushed..
    document.getElementById('generateBtn')
        .addEventListener('click', generateCharts);

    // When reset button is pushed‚Ä¶
    // Reset all inputs back to their original defaults, then redraw
    document.getElementById('resetBtn')
        .addEventListener('click', () => {
            // grab every input/select in the controls panel
            document.querySelectorAll('#inputs input, #inputs select')
                .forEach(el => {
                    // reset to whatever was in the HTML ‚Äúvalue=‚Äù or ‚Äúselected=‚Äù by default
                    el.value = el.defaultValue;
                });

            // re‚Äêrun the charts with those restored defaults
            generateCharts();
        });

    // ‚îÄ‚îÄ‚îÄ Auto‚Äìrefresh on input change (2 s debounce) ‚îÄ‚îÄ‚îÄ
    ; (function () {
        let redrawTimer;
        // Listen on every input or select in your parameters panel
        const inputs = document.querySelectorAll('#inputs input, #inputs select');
        inputs.forEach(el => {
            el.addEventListener('input', () => {
                clearTimeout(redrawTimer);
                // wait 2 seconds after the last keystroke before redrawing
                redrawTimer = setTimeout(() => {
                    generateCharts();
                }, 2000);
            });
        });
    })();
    // 1Ô∏è‚É£ Hook up the Export button
    document.getElementById('exportCsvBtn')
        .addEventListener('click', exportCsv);

    function exportCsv() {



        // 2Ô∏è‚É£ Grab your data from the last simulation run
        // assume these arrays & stats are in scope or you re‚Äìcall simulateRetention here
        // ‚îÄ‚îÄ A) Grab the report name input ‚îÄ‚îÄ
        const reportName = document.getElementById('reportName').value.trim() || 'Report';
        // ‚îÄ‚îÄ 1) Re-read all your inputs ‚îÄ‚îÄ
        const sourceSizeTiB = parseFloat(document.getElementById('sourceSize').value);
        const changeRate = parseFloat(document.getElementById('changeRate').value) / 100;
        const dailyRetention = parseInt(document.getElementById('dailyRetention').value, 10);
        const weeklyRetention = parseInt(document.getElementById('weeklyRetention').value, 10);
        const monthlyRetention = parseInt(document.getElementById('monthlyRetention').value, 10);
        const yearlyRetention = parseInt(document.getElementById('yearlyRetention').value, 10);
        const compressionPct = parseFloat(document.getElementById('compression').value) / 100;
        const cloudDelay = parseInt(document.getElementById('cloudDelay').value, 10);

        const simMonths = parseInt(document.getElementById('simulationMonths').value, 10);
        const days = simMonths * 30;    // exactly as in generateCharts()
        // Rebuild the same daysLabels you use in generateCharts:
        const daysLabels = Array.from({ length: days }, (_, i) => `Day ${i + 1}`);


        const {
            storedLocallyOverTime,
            storedInCloudOverTime,
            compressedDataOverTime,
            dedupeEfficiencyOverTime,
            dedupePreCompressionOverTime,
            requiredKeysSeries,
            blockMapOverTime,
            heldRawDataOverTime,
            stats } = simulateRetention(
                days, sourceSizeTiB, changeRate, compressionPct,
                dailyRetention, weeklyRetention, monthlyRetention,
                yearlyRetention, cloudDelay
            );

        // 3Ô∏è‚É£ Build the CSV rows
        const rows = [];
        // 1) Report title row
        rows.push([reportName]);
        rows.push([]);  // blank line

        //add Recommendations to CSV
        const currentTier = stats.dictionary.tier;
        const usedPct = stats.dictionary.usedPct;
        // find its index in your lookup table
        const idx = keyLookupTable.findIndex(
            k => k.Size === currentTier.Size && k.Base_RAM === currentTier.Base_RAM
        );

        // pick the next-higher tier if ‚â•90%
        let recTier = currentTier;
        if (usedPct >= 90 && idx >= 0 && idx < keyLookupTable.length - 1) {
            recTier = keyLookupTable[idx + 1];
        }

        // ‚Äî Summary section ‚Äî
        rows.push(['Metric', 'Value']);
        rows.push(['Total Logical (TiB)', stats.totalLogicalTiB.toFixed(2)]);
        rows.push(['Total Stored (TiB)', stats.totalStoredTiB.toFixed(2)]);
        rows.push(['Total Cloud (TiB)', stats.totalCloudTiB.toFixed(2)]);
        // prefer stats.heldRawDataTiB, but fallback to the last day from the series
        let heldRawTiB = stats.heldRawDataTiB;
        if (heldRawTiB === undefined || isNaN(heldRawTiB)) {
            heldRawTiB = heldRawDataOverTime.at(-1) || 0;
        }
        rows.push(['Held Raw (TiB)', heldRawTiB.toFixed(2)]);
        rows.push(['Held Raw (TiB)', heldRawTiB.toFixed(2)]);
        rows.push(['Snapshots Held', stats.snapshotsHeld]);

        // Use stats if defined, otherwise take last element of the series
        const prePct = stats.dedupePreCompressionPct !== undefined
            ? stats.dedupePreCompressionPct
            : (dedupePreCompressionOverTime.at(-1) || 0);

        const postPct = stats.dedupePostCompressionPct !== undefined
            ? stats.dedupePostCompressionPct
            : (dedupeEfficiencyOverTime.at(-1) || 0);
        rows.push(['Dedup Pre-Compression (%)', prePct.toFixed(2)]);
        rows.push(['Dedup Post-Compression (%)', postPct.toFixed(2)]);

        rows.push(['Required Keys', stats.dictionary.requiredKeys]);
        rows.push(['Used Keys (%)', stats.dictionary.usedPct.toFixed(2)]);
        rows.push(['Block Map Size (GiB)', stats.blockMapSizeGiB.toFixed(2)]);

        rows.push([]); // blank line

        // ‚îÄ‚îÄ Recommended Configuration ‚îÄ‚îÄ

        rows.push(['Recommended Configuration', '']);
        rows.push(['Base RAM', recTier.Base_RAM || 'N/A']);
        rows.push(['Dict Size', recTier.Size || 'N/A']);
        rows.push(['Additional RAM', recTier.Additional_RAM || 'N/A']);
        rows.push(['Shift', recTier.Shift || 'N/A']);
        rows.push(['Page Shift', recTier.Page_Shift || 'N/A']);

        rows.push([]); // another blank line

        // ‚Äî Daily series header ‚Äî
        rows.push([
            'Day',
            'Local (TiB)',
            'Cloud (TiB)',
            'Total Stored (TiB)',
            'Dedup Eff (%)',
            'Pre-Comp Eff (%)',
            'Required Keys',
            'Meta-Data (GiB)'
        ]);

        // ‚Äî Daily rows ‚Äî
        daysLabels.forEach((day, i) => {
            rows.push([
                day,
                storedLocallyOverTime[i].toFixed(2),
                storedInCloudOverTime[i].toFixed(2),
                compressedDataOverTime[i].toFixed(2),
                dedupeEfficiencyOverTime[i].toFixed(2),
                dedupePreCompressionOverTime[i].toFixed(2),
                requiredKeysSeries[i],
                blockMapOverTime[i].toFixed(2)
            ]);
        });

        // 4Ô∏è‚É£ Serialize to CSV string
        const csvContent = rows.map(r =>
            r.map(cell => `"${cell}"`).join(',')
        ).join('\r\n');

        // 5Ô∏è‚É£ Trigger download
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'dedupe_simulation.csv';
        a.click();
        URL.revokeObjectURL(url);
    }
</script>
</body>

</html>